/*  Copyright 1999 Vince Via vvia@viaoa.com
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
package com.viaoa.datasource.jdbc.delegate;

import java.io.StringBufferInputStream;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.logging.Logger;

import com.viaoa.datasource.jdbc.OADataSourceJDBC;
import com.viaoa.datasource.jdbc.db.Column;
import com.viaoa.datasource.jdbc.db.DBMetaData;
import com.viaoa.datasource.jdbc.db.Link;
import com.viaoa.datasource.jdbc.db.Table;
import com.viaoa.object.OAObject;
import com.viaoa.object.OAObjectDSDelegate;
import com.viaoa.object.OAObjectKey;
import com.viaoa.object.OAObjectReflectDelegate;
import com.viaoa.util.OAString;

/**
 * Manages inserts for JDBC datasource.
 * 
 * @author vvia
 */
public class InsertDelegate {

	private static Logger LOG = Logger.getLogger(InsertDelegate.class.getName());

	public static void insertWithoutReferences(OADataSourceJDBC ds, OAObject obj) {
		if (obj == null) {
			return;
		}
		insert(ds, obj, obj.getClass(), false);
	}

	public static void insert(OADataSourceJDBC ds, OAObject object) {
		if (object == null) {
			return;
		}
		insert(ds, object, object.getClass(), true);
	}

	private static void insert(OADataSourceJDBC ds, OAObject oaObj, Class clazz, boolean bIncludeRefereces) {
		Class c = clazz.getSuperclass();
		if (c != null && !c.equals(OAObject.class)) {
			insert(ds, oaObj, c, bIncludeRefereces);
		}

		Column columnSkip = null;
		Table table = ds.getDatabase().getTable(clazz);
		if (table != null) {
			Column[] columns = table.getColumns();
			for (int i = 0; columns != null && i < columns.length; i++) {
				if (ds.getDBMetaData().supportsAutoAssign && columns[i].assignNextNumber && columns[i].assignedByDatabase) {
					columnSkip = columns[i];
					break;
				}
			}
		}
		Object[] objs = null;
		try {
			objs = getInsertSQL(ds, oaObj, clazz, columnSkip, bIncludeRefereces);
			Object[] params = null;
			ArrayList al = (ArrayList) objs[1];
			if (al != null) {
				int x = al.size();
				params = new Object[x];
				for (int i = 0; i < x; i++) {
					params[i] = al.get(i);
				}
			}

			performInsert(ds, oaObj, (String) objs[0], params, columnSkip);
		} catch (Exception e) {
			if (objs == null || objs.length == 0) {
				objs = new String[] { "no sql generated" };
			}
			//LOG.log(Level.WARNING, "insert(), sql="+objs[0], e);
			throw new RuntimeException("Error on insert, sql=" + objs[0], e);
		}
	}

	private static Object[] getInsertSQL(OADataSourceJDBC ds, OAObject oaObj, Class clazz, Column columnSkip, boolean bIncludeRefereces)
			throws Exception {
		Table table = ds.getDatabase().getTable(clazz);
		if (table == null) {
			throw new Exception("cant find table for Class " + clazz.getName());
		}

		Column[] columns = table.getColumns();
		StringBuffer str = new StringBuffer(128);
		StringBuffer values = new StringBuffer(128);
		ArrayList<Object> alValue = null;
		String value;
		DBMetaData dbmd = ds.getDBMetaData();
		for (int i = 0; columns != null && i < columns.length; i++) {
			Column column = columns[i];
			if (column == columnSkip) {
				continue;
			}
			if (column.propertyName == null || column.propertyName.length() == 0) {
				continue;
			}
			if (column.readOnly) {
				continue;
			}

			Object obj = oaObj.getProperty(column.propertyName);
			// see if column needs to be assigned to a seq number
			// support for DB generated keys
			if (column.primaryKey) {
				boolean b = false;
				if (obj == null) {
					b = true;
				} else if (obj instanceof Number) {
					if (((Number) obj).intValue() == 0) {
						b = true;
					} else {
						// this will make sure that the assigned number does not mess up the nextNumber generator
						AutonumberDelegate.verifyNumberUsed(ds, oaObj, table, column, ((Number) obj).intValue());
					}
				}
				if (b) {
					if (column.assignedByDatabase && dbmd.supportsAutoAssign) {
						continue; // generated by DB
					}
					AutonumberDelegate.assignNumber(ds, oaObj, table, column);
					obj = oaObj.getProperty(column.propertyName);
				}
			}

			boolean bNull = (obj == null);

			String origValue = null;
			// 20100514
			boolean byteArray = (obj instanceof byte[]);
			if (byteArray) {
				if (alValue == null) {
					alValue = new ArrayList(3);
				}
				alValue.add(obj);
				value = "?";
			} else {
				boolean bOver512 = obj != null && obj instanceof String && ((String) obj).length() > 512;
				// this will convert to SQL string
				value = ConverterDelegate.convertToString(	dbmd, obj, !bOver512, Delegate.getMaxLength(column), column.decimalPlaces,
															column);
				origValue = value;
				if (value != null && bOver512) {
					if (alValue == null) {
						alValue = new ArrayList<Object>(3);
					}
					alValue.add(value);
					value = "?";
				}
			}
			if (str.length() > 0) {
				str.append(", ");
				values.append(", ");
			}
			str.append(dbmd.leftBracket + column.columnName.toUpperCase() + dbmd.rightBracket);
			values.append(value);

			// check for case sensitive column
			if (!byteArray && dbmd.caseSensitive) {
				String colNameLower = column.columnLowerName;
				if (OAString.isNotEmpty(colNameLower) && !colNameLower.equalsIgnoreCase(column.columnName)) {
					value = origValue;
					if (value != null) {
						value = value.toLowerCase();
					}
					if (value != null && value.length() > 512) {
						alValue.add(value);
						value = "?";
					}
					str.append(", ");
					values.append(", ");
					str.append(dbmd.leftBracket + colNameLower.toUpperCase() + dbmd.rightBracket);
					values.append(value);
				}
			}
		}

		// update Fkeys
		Link[] links = table.getLinks();
		for (int i = 0; bIncludeRefereces && links != null && i < links.length; i++) {
			if (links[i].fkeys == null || (links[i].fkeys.length == 0)) {
				continue;
			}
			if (links[i].fkeys[0].primaryKey) {
				continue; // one2many, or one2one (where Key is the fkey)
			}

			OAObjectKey key = OAObjectReflectDelegate.getPropertyObjectKey(oaObj, links[i].propertyName);
			if (key == null) {
				continue; // null
			}
			Object[] ids;
			ids = key.getObjectIds();

			Column[] fkeys = table.getLinkToColumns(links[i], links[i].toTable);
			if (fkeys == null) {
				continue;
			}
			if (fkeys.length != links[i].fkeys.length) {
				continue;
			}
			for (int j = 0; j < fkeys.length; j++) {
				Object objProperty = ((ids == null) || (j >= ids.length)) ? null : ids[j];
				value = ConverterDelegate.convert(dbmd, fkeys[j], objProperty);
				if (str.length() > 0) {
					str.append(", ");
					values.append(", ");
				}

				str.append(dbmd.leftBracket + links[i].fkeys[j].columnName.toUpperCase() + dbmd.rightBracket);
				values.append(value);
			}
		}
		str = new StringBuffer("INSERT INTO " + dbmd.leftBracket + table.name.toUpperCase() + dbmd.rightBracket + " (" + str + ") VALUES ("
				+ values + ")");
		return new Object[] { new String(str), alValue };
	}

	private static void performInsert(OADataSourceJDBC ds, OAObject oaObj, String sqlInsert, Object[] params, Column columnAutoGen)
			throws Exception {

		/*
		OAObjectKey key = OAObjectKeyDelegate.getKey(oaObj);
		String s = String.format("Insert, class=%s, id=%s, sql=%s",
		        OAString.getClassName(oaObj.getClass()),
		        key.toString(),
		        sqlInsert
		);
		OAObjectInfo oi = OAObjectInfoDelegate.getOAObjectInfo(oaObj);
		if (oi.getUseDataSource()) {
		    OAObject.OALOG.fine(s);
		}
		
		LOG.fine(s);
		           
		DBLogDelegate.logInsert(sqlInsert, params);
		*/
		//qqqqqqqqqqqqqqq        
		DBLogDelegate.logInsert(sqlInsert, params);

		Statement statement = null;
		PreparedStatement preparedStatement = null;
		try {
			int x = 0;
			if (params != null && params.length > 0) {
				if (ds.getDBMetaData().databaseType == DBMetaData.ACCESS) {
					preparedStatement = ds.getPreparedStatement(sqlInsert);
					columnAutoGen = null;
				} else {
					preparedStatement = ds.getPreparedStatement(sqlInsert, (columnAutoGen != null));
				}

				for (int i = 0; i < params.length; i++) {
					if (params[i] instanceof String) {
						preparedStatement.setAsciiStream(	i + 1, new StringBufferInputStream((String) params[i]),
															((String) params[i]).length());
					} else {
						// 20100504
						preparedStatement.setBytes(i + 1, (byte[]) (params[i]));
					}

				}
				x = preparedStatement.executeUpdate();
			} else {
				statement = ds.getStatement(sqlInsert);
				if (ds.getDBMetaData().databaseType == DBMetaData.ACCESS) {
					x = statement.executeUpdate(sqlInsert);
					columnAutoGen = null;
				} else {
					int param = (columnAutoGen != null) ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS;
					x = statement.executeUpdate(sqlInsert, param);
				}
			}
			if (x != 1) {
				LOG.warning("could not insert, sql=" + sqlInsert);
				throw new Exception("row was not INSERTed, no exception thrown");
			}

			if (columnAutoGen != null) {
				ResultSet rs;
				if (preparedStatement != null) {
					rs = preparedStatement.getGeneratedKeys();
				} else {
					rs = statement.getGeneratedKeys();
				}

				if (rs.next()) {
					Object val = rs.getObject(1);

					try {
						OAObjectDSDelegate.setAssigningId(oaObj, true);
						oaObj.setProperty(columnAutoGen.propertyName, val);
					} finally {
						OAObjectDSDelegate.setAssigningId(oaObj, false);
					}
				}
				rs.close();
			}
		} finally {
			if (statement != null) {
				ds.releaseStatement(statement);
			}
			if (preparedStatement != null) {
				ds.releasePreparedStatement(preparedStatement);
			}
		}
	}

}
